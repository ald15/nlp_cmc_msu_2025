# Практическое задание №1

- Тема: `2025-AL. Декораторы, итераторы, классы. 2025`.
- Ссылка на задание: [Яндекс контест](https://contest.yandex.ru/contest/84946/enter)

## Условие задач

- [Задача №1]()
- [Задача №2]()
- [Задача №3]()

### Задача №1

Название: `A. 2025-AL. Генератор батчей. 2025`.

| Ограничения | Значение |
| :---:| :---: |
| Ограничение времени | 0.4 секунды |
| Ограничение памяти | 32 Мб |
| Ввод | стандартный ввод или input.txt |
| Вывод | стандартный вывод или output.txt |

**Условие**:

> Напишите класс `BatchGenerator`, который принимает на вход список последовательностей, размер батча и параметр `shuffle` и возвращает генератор, разбивающий входные последовательности на батчи заданного размера, а также случайным образом перемешивает их если `shuffle=True`.

```python
def __init__(self, list_of_sequences, batch_size, shuffle=False):
    """
    :param list_of_sequences: Список списков или numpy.array одинаковой длины
    :param batch_size: Размер батчей, на которые нужно разбить входные последовательности.
        Батчи последнего элемента генератора могут быть короче чем batch_size
    :param shuffle: Флаг, позволяющий перемешивать порядок элементов в последовательностях
    """

    pass
```

Примеры правильно работающего кода:

```python
bg = BatchGenerator(
    list_of_sequences=[
        [1, 2, 3, 5, 1, 'a'], 
        [0, 0, 1, 1, 0, 1]
    ], batch_size=2, shuffle=False
)
for elem in bg:
    print(elem)
```

Вывод:
```txt
[[1, 2], [0, 0]]
[[3, 5], [1, 1]]
```

**Замечание**: в принципе, реализовывать именно через `__init__` необязательно. Можно реализовывать и как итератор, и как генератор.

---

### Задача №2

Название: `B. 2025-AL. Проверка аргументов. 2025`.

| Ограничения | Значение |
| :---:| :---: |
| Ограничение времени | 0.2 секунды |
| Ограничение памяти | 16 Мб |
| Ввод | стандартный ввод или input.txt |
| Вывод | стандартный вывод или output.txt |

**Условие**:
> Напишите декоратор `check_arguments`, который будет проверять правильность типов входных позиционных аргументов функции.
>
> Декоратор принимает на вход типы аргументов и декорирует функцию таким образом, что она генеририрует исключение `TypeError`, если хотя бы один из аргументов имеет неверный тип. Типов может быть меньше чем аргументов, в этом случае проверяются типы только первых аргументов, для которых типы прописаны. Типов может быть больше чем аргументов, в этом случае необходимо вывести ошибку. Декоратор должен корректно обрабатывать функции с переменным числом аргументов. Декоратор не обязан корректно работать с функциями с именованными аргументами.

---

### Задача №3

Название: `C. 2025-AL. Полиномы. 2025`.

| Ограничения | Значение |
| :---:| :---: |
| Ограничение времени | 1 секунда |
| Ограничение памяти | 64 Мб |
| Ввод | стандартный ввод или input.txt |
| Вывод | стандартный вывод или output.txt |

**Условие**:
> Реализуйте модуль `polynomial.py`, содержащий класс `Polynomial`, который описывает полином. Конструктор класса (метод `__init__`) принимает неограниченное число аргументов, каждый из которых является коэффициентом полинома. Номер аргумента соответствует степени монома, к которому относится данный коэффициент (нумерация с нуля).
>
> ... 
> [TODO]

## Выполнение

| № | Статус готовности | Дата выполнения | Дата отправки| Статус сдачи |
| --- | --- | --- | --- | --- |
| 1 | ❌ | XX.11.2025 | XX.11.2025 | ❌ |
| 2 | ❌ | XX.11.2025 | XX.11.2025 | ❌ |
| 3 | ❌ | XX.11.2025 | XX.11.2025 | ❌ |


